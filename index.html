<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Zoom and anti-aliasing | Canvas pixel manipulation</title>
</head>

<body>
  <table>
    <thead>
      <tr>
        <th>source</th>
        <th>zoomed pixels</th>
        <th>result</th>
        <th>processed</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
          <canvas id="canvas" width="300" height="227"></canvas>
        </td>
        <td align="center">
          <canvas id="pixelated-zoom" width="200" height="200"></canvas>
        </td>
        <td align="center">
          <canvas id="result" width="50" height="50"></canvas>
        </td>
        <td align="center">
          <canvas id="processed" width="200" height="200"></canvas>
        </td>
      </tr>
    </tbody>
    <table>
      <script type="text/javascript">
        'use strict';
        (function () {

          // main canvas
          var canvas = document.getElementById('canvas');
          var ctx = canvas.getContext('2d');

          // zoomed canvas
          var pixelatedZoomCtx = document.getElementById('pixelated-zoom').getContext('2d');
          pixelatedZoomCtx.imageSmoothingEnabled = false;
          pixelatedZoomCtx.mozImageSmoothingEnabled = false;
          pixelatedZoomCtx.webkitImageSmoothingEnabled = false;
          pixelatedZoomCtx.msImageSmoothingEnabled = false;

          // result canvas
          const resultCanavs = document.getElementById('result');
          const resultCtx = resultCanavs.getContext('2d');

          // orignal image data (buffer), used to query pixel value
          let imageData0 = undefined;
          let curAlphaData = undefined;

          // load image(will be through file loading)
          var img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = 'test.jpeg';
          img.onload = function () {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            console.log(`w = ${img.width} h = ${img.height}`);
            imageData0 = ctx.getImageData(0, 0, img.width, img.height);

            // transparent black image, used to store alpha
            curAlphaData = ctx.createImageData(imageData0);
            for (let i = 0; i < imageData0.data.length; i += 4) {
              // Modify pixel data
              curAlphaData.data[i + 0] = imageData0.data[i + 0];
              curAlphaData.data[i + 1] = imageData0.data[i + 1];
              curAlphaData.data[i + 2] = imageData0.data[i + 2];
              curAlphaData.data[i + 3] = imageData0.data[i + 3];
            }

            console.log(curAlphaData);
          };

          // The Uint8ClampedArray contains height × width × 4 bytes of data, with index values ranging from 0 to (height×width×4)-1.
          const getPixelValue = function (img, x, y) {
            if (x < 0 || y < 0 || x >= img.width || y >= img.height) console.error(`getPixelValue out of range!`);
            const index = 4 * (y * img.width + x);
            return [img.data[index + 0], img.data[index + 1], img.data[index + 2], img.data[index + 3]];
          }

          var drawEyeDroper = function (ctx, x, y) {
            const r = 4;
            const w = r * 2 + 1;
            ctx.drawImage(canvas,
              Math.min(Math.max(0, x - r), img.width - w),
              Math.min(Math.max(0, y - r), img.height - w),
              w, w,
              0, 0,
              200, 200);
          };

          const floodfill = function () {

          }


          let isDragging = false;
          let lastX = undefined;
          let lastY = undefined;
          let selectedColor = undefined; // [r,g,b,a]
          const maxDragDistane = 200.0;

          // when mouse down, thresh is set
          canvas.addEventListener('mousedown', function (e) {
            selectedColor = getPixelValue(imageData0, e.layerX, e.layerY);
            isDragging = true;

            lastX = e.layerX;
            lastY = e.layerY;
          });

          canvas.addEventListener('mouseup', function (e) {
            isDragging = false;
            selectedColor = undefined;

            lastX = e.layerX;
            lastY = e.layerY;
          });

          canvas.addEventListener('mousemove', function (e) {
            const x = e.layerX;
            const y = e.layerY;
            drawEyeDroper(pixelatedZoomCtx, x, y);

            // show the selected pixel
            const color = getPixelValue(imageData0, x, y);
            const rgba = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})`;
            resultCanavs.style.background = rgba;

            // if mouse is down, calc 
            if (isDragging) {
              const dis = Math.sqrt((e.layerX - lastX) * (e.layerX - lastX) + (e.layerY - lastY) * (e.layerY - lastY));
              const disRatio = Math.min(dis / maxDragDistane, 1);
              console.log(`drag ratio = ${disRatio}`);

              // flood and generate some transparent pixels save to a new imagedata
              floodfill();

              // put the image data to canvas to show

            }
          });


        })()
      </script>
</body>

</html>